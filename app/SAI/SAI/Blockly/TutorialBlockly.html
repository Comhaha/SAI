<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="https://unpkg.com/blockly@10.3.1/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly@10.3.1/python_compressed.js"></script>
    <script src="TutorialBlocks.js"></script>
</head>
<body>
    <div id="blocklyDiv" style="height: 96vh; width: 96vw; "></div>
    <xml id="toolbox" style="display: none">
        <block type="start"></block>
        <block type="pipInstall"></block>
        <block type="loadModel"></block>
        <block type="loadDataset"></block>
        <block type="machineLearning"></block>
        <block type="resultGraph"></block>
        <block type="imgPath"></block>
        <block type="modelInference"></block>
        <block type="visualizeResult"></block>
    </xml>

    <div id="customAlert" style="
        display: none;
        position: fixed;
        top: 30%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        padding: 20px;
        background-color: white;
        border: 2px solid black;
        border-radius: 8px;
        z-index: 9999;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
        <p id="customAlertText"></p>
        <button onclick="closeCustomAlert()">확인</button>
    </div>

    <script>
        //const workspace = Blockly.inject('blocklyDiv', {
        //    toolbox: null,
        //    //toolbox: document.getElementById('toolbox')
        //});
		Blockly.Tooltip.HOVER_MS = 100; // 기본값은 1000ms

		const workspace = Blockly.inject('blocklyDiv', {
			toolbox: null, // 혹은 document.getElementById('toolbox') 사용 가능
			//scrollbars: true, // 수평 + 수직 스크롤바 모두 사용 (공식 지원 방식)
			trashcan: false,
			zoom: {
				controls: true,
				wheel: true,
				startScale: 2.0,
				maxScale: 4,
				minScale: 1,
				scaleSpeed: 1.2,
				pinch: true
			},
			renderer: 'geras', // 또는 'zelos', 'thrasos' 등 (기본: 'geras')
            move: {
                scrollbars: true,
				drag: true,
				wheel: true
			}
		});

        function showCustomAlert(text) {
            document.getElementById('customAlertText').innerText = text;
            document.getElementById('customAlert').style.display = 'block';
        }

        function closeCustomAlert() {
            document.getElementById('customAlert').style.display = 'none';
        }
        
        function addBlock(type) {
            const block = workspace.newBlock(type);
            block.initSvg();
            block.render();
        }

		// 블록을 생성할 때마다 Python 코드를 생성하여 C#으로 전송  
        function sendCode(code) {
            console.log("[DEBUG] JavaScript: 블록 코드 생성");
            console.log("[DEBUG] 생성된 코드 길이:", code.length);
            console.log("[DEBUG] 생성된 코드 내용:\n", code);
            
			window.chrome.webview.postMessage({
				type: "blockAllCode",
				code: code
			});
        }

        // 하나의 블럭 코드 가져오기
		function getPythonCodeByType(blockType) {
			const blocks = workspace.getAllBlocks();
			for (let block of blocks) {
                if (block.type === blockType) {
					window.chrome.webview.postMessage({
						type: "blockCode",
						code: Blockly.Python.blockToCode(block)
					});
                    break;
				}
			}
        }

        // 모든 블럭 삭제
        function clear() {
			workspace.clear();
        }

        // 이전 상태로 되돌리기(ctrl+z)
        function undo() {
			workspace.undo(false);
        }

        // 이전 상태 다시 실행하기(ctrl+y)
        function redo() {
			workspace.undo(true);
        }

		function registerDoubleClickEvent(block) {
			if (!block.svgGroup_ || block.svgGroup_.dataset.dblclickBound) return;

			block.svgGroup_.addEventListener('dblclick', () => {
				try {
					const code = Blockly.Python.blockToCode(block);
					const json = {
						type: "blockDoubleClick",
						code: code,
					};
					window.chrome.webview.postMessage(json);
				} catch (e) {
					showCustomAlert('블록 코드를 생성하는 중 오류가 발생했습니다.');
					console.error(e);
				}
			});

			// 중복 방지 플래그
			block.svgGroup_.dataset.dblclickBound = true;
        }

		function bindDoubleClickEventsToAllBlocks() {
			const blocks = workspace.getAllBlocks(false);
			for (let block of blocks) {
				registerDoubleClickEvent(block);
			}
		}

		// 블록 생성 시 Python 코드 생성
        window.addEventListener('DOMContentLoaded', () => {
            workspace.addChangeListener((event) => {
                if (
                    event.type === Blockly.Events.BLOCK_CREATE ||
                    event.type === Blockly.Events.BLOCK_DELETE ||
                    event.type === Blockly.Events.BLOCK_CHANGE ||
                    event.type === Blockly.Events.BLOCK_MOVE
                ) {
					bindDoubleClickEventsToAllBlocks(); // 더블클릭 리스너 바인딩

                    // 안전하게 확인
                    if (Blockly.Python && Blockly.Python.workspaceToCode) {
                        const code = Blockly.Python.workspaceToCode(workspace);
						sendCode(code);
                    } else {
                        showCustomAlert('Blockly.Python.workspaceToCode가 아직 정의되지 않았습니다.');
                    }
                }
            });
        });

		// 나만의 필드 타입(모델 선택 버튼)
		class FieldFilePicker extends Blockly.Field {
			static fromJson(options) {
				return new FieldFilePicker(options['value']);
			}

			showEditor_() {
				// C#에게 파일 열라고 요청
				const blockId = this.sourceBlock_.id;
				window.chrome.webview.postMessage({
					type: "openFile",
					blockId: blockId
				});
            }

			// C#에서 경로가 돌아오면 이 값을 필드에 설정
			setImagePath(path) {
				this.setValue(path);
			}
		}
        Blockly.fieldRegistry.register('field_filepicker', FieldFilePicker);

		// JS가 메시지 수신 (C# → JS)
		window.addEventListener("message", (event) => {
			const { blockId, filePath } = event.data;
            const block = Blockly.getMainWorkspace().getBlockById(blockId);
			if (!block) return;

			const fields = block.inputList.flatMap(input => input.fieldRow);
			const filePickerField = fields.find(f => f instanceof FieldFilePicker);

			if (filePickerField) {
				filePickerField.setImagePath(filePath);
			}
		});

    </script>

</body>
</html>